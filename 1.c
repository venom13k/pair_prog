#include <stdio.h>

/*
   Задание:
   [+] 1. Массив из 10 элементов
   [+] 2. Заполнить массив (через for, Гыыыы)
   [+] 3. Вывести массив на экран(а допустимо вообще
          выводить массив на экран при заполнении сразу? Лучше не надо)
          Кесарю кесарево...
   [+] 4. Массив из n элементов (через #define)
   [+] 5. Динамический массив из 10 элементов
   [+] 6. Динамический массив из n элементов(во время выполнения,
          т.е. теперь через переменную должен считаться размер)
   [+] 7. Функция заполнения массива из n элементов
   [+] 8. Функция вывода массива из n элементов
   [ ] 9. написать memset заполняет в массиве m первые n байт числом k
   [ ] 10. написать memcpy из массива src копирует  n байт в массив dest
   [ ] 11. Что есть список? (реализацию не смотреть, описание что это такое, гугл)
          Односвязный.
   [ ] 12. Примерная структура (struct) списка из int'ов
   [ ] 13.

   Косяки:
   1. Точки с запятой не ставишь
   2. Пробелами не выделяешь =, <, ;
   3. return 0
   4. аргументов таких нигде не бывает func(%d, 33) - только строки
   5. размер обычных массивов вычисляется на уровне компиляции,т.е.
   числа должны быть написаны как есть (не через переменные) или через
   #define(--КТО СКАЗАЛ?--) ЯЯЯЯЯЯЯЯЯ отметь сделанные 4,5,6
   6. Объявляются указатели через звёздочку, так: *m.
   7. ты создал указатель на массив из 10 элементов
*/

/*
 выделил 100 байт - допустим внутри int (допустим он 4 байта)
т.е. 100 / 4 - 25 элементов массив из int


1  .....         100
____________________
|4|4|4|4|4 ....   4|
-------------------- 
т.е. чтобы создать 100 элементов int'ов нужно 400 байт памяти 
sizeof(int)*100, а можно просто написать 400 ;)
но malloc это уже настоящая функция с аргументом, т.е. можно
подставлять что угодно туда - хоть переменную, хоть число.
т.е. в принципе маллоку пофигу что ты хочешь туда поместить
ему главное знать размер этого
а норм.
*/


// можно но лучше не надо
// ватный стиль указатели понятнее
//да? А вот мне понятней что это массив в аргументы надо задавать
// это тоже не очент ясно....
// у тебя же в мэйн не массив так?
// у тебя указатель.
// почему у тебя в мэйне не массив?
// - потому что х.з что туда задавать
// куда туда?
//  - ну если создавать переменную
// давай так научимся нормально говорить =)
// во представь на уровне компьютера как это выглядит
// что есть переменная?
// навряд ли... Скорее регистр какой-нибудь, но может и память
// это не так важно: вот тебе дали переменную int a; ты туда можешь запихнуть число
// но что есть указатель  *int - тоже самое!!!
// только он хранит адрес (который указывает на int)
// надо именно представить это
//
// допустим есть int* v, мы можем двигать изменяя его адрес &v
// да просто v = 3333; нет v - уже есть адрес(это указатель). & - это оператор взятия адреса
// v = v + 1; но ты можешь потеряться. зачем нужен маллок - чтобы дать тебе легальную память (как бы купить)
// но ты можешь к другому в огород залезть... И это косяк многих программ на си.
/* и ты можешь его двигать - си тебе этого не запрещает
   но ты можешь себе яйца отстрелить. если выйдешь за дозволенное
  /указатель
  V
 ---------------
 |ПАМЯТЬ       |
 ---------------
 */
// - взять чужую память? Как? Я думал по любому возьмешь свободную, не к кому в огород не полезешь...
// это низкий уровень
// си очень низкий уровень
// ты можешь что угодно делать
// как я уже сказал - прямо напрямую указатель задать на нужную память
// погоди адрес выглядит по-другому по-моему, V - это значение указателя, нет?
// *v - это значение



void massin(int* a, int len) {

  int i;
    for(i = 0; i < len; i++) {
      a[i] = i;
    }
}

void massin2(int* a, int len) {

  int i;
    for(i = 0; i < len; i++) {
      a[i] = len - i;
    }
}

void massout(int* a, int len) {
  int i;
    for(i = 0; i < len; i++) {
      printf("%d  Addres: %ld\n",a[i], &a[i]);
    }

}

void memset(char *s, char c, int n) { //тип char приводит аргумент к побайтовому виду

  int i;
    for(i = 0; i < n; i++) {
      s[i] = c;

      }
}
void massset(int *s, int c, int n) {

  int i;
    for(i = 0; i < n; i++) {
	s[i] = c;

      }
}

void memcpy2(char *kuda, char *otkuda, int n) {

  int i;

  for(i = 0; i < n; i++) {
    kuda[i] = otkuda[i];
  }
}

int main()
{
  int *m;
  int i;
  int n;
  int *d;
  n = 55;
  
  m = malloc(n*sizeof(int));
  d = malloc(n*sizeof(int));
  
  massin(m, 15);
  massin2(d, 15);
 
  // memcpy2(m, d, 5);
  memset(m, 5, 10);
  massout(m, 15);

  free(d);
  free(m); 
  return 0;
  // здесь совсем его не трогай ;)
                           //это






    /*    printf("\nChanging of bytes:\n");

    for(i = 0; i < l; i++) {
      m[j] = m[j] & 0<<set;
      printf(" %d %d %d\n",m[j],j,i);
      set+=8;
      if(i % sizeof(*m) == 0) {
	j++;
      }      
    }
    set = 0;
    for(i = 0,j = 0; i < l; i++) {
      m[j] = m[j] | k<<set;
      printf(" %d %d %d\n",m[j],j,i);
      set+=8;
      if(i % sizeof(*m) == 0) {
	j++;
      }
	  
	  //	  *(&m[0] + i) = k;
	  printf("                       %d  %ld \n", m[i],&m[i]);  
      
      }
    */






  // теперь только здесь трогая и сделай вывод от 10 до 20
  // вот она адресная арифметика... Заметь в функцию всё от нуля ;) Всё относительно
  // здесь сдвинули а там даже не подозревают, что мы сдваинули
  // ничего мы не меняли
  // m + 10 - это новый адрес (смещённый) всё спать завтра в 9:00 продолжим утра.
 

  /*  m = m + 10;
  massout(m, 11);
  m = m - 10;
  */

}
